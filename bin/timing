#!/usr/bin/env python3

# This program is used to measure how much time a StarSmasher simulation took to
# run. It uses os.getmtime to measure timings.

import starsmashertools
import starsmashertools.preferences
import starsmashertools.mpl.plotdata
import starsmashertools.helpers.path
import starsmashertools.bintools.cli
import starsmashertools.bintools
import starsmashertools.helpers.path
import collections
import os
import numpy as np
import warnings
import copy

################################################################################
################################## Back end ####################################
################################################################################

MIN_PLOT_APPARENT_SIZE = (0.25, 0.25)

# Gets set in the front end
simulation = None
cli = None

def get_time_table():
    global simulation
    
    logcolumn = []
    outcolumn = []
    totalcolumn = []
    fraccolumn = []

    fmt = "%10s:   %s ... %s"
    filenames = simulation.get_outputfiles()
    longest = -float('inf')
    summed = 0
    for logfile in simulation.get_logfiles():
        logcolumn += [starsmashertools.helpers.path.basename(logfile.path)]

        has = logfile.hasOutputFiles(filenames)
        first = None
        for i, h in enumerate(has):
            if h:
                first = filenames[i]
                break
        last = None
        for i, h in enumerate(has[::-1]):
            if h:
                last = filenames[len(filenames) - i - 1]
                break

        if first is None and last is None:
            totalcolumn += [0]
            continue

        fmt2 = '%s ... %s'
        if None in [first, last]:
            fmt2 = '%s'
        
        outcolumn += ["%s ... %s" % (
            starsmashertools.helpers.path.basename(first),
            starsmashertools.helpers.path.basename(last),
        )]
        t1 = first.get_file_creation_time()
        t2 = last.get_file_creation_time()
        totalcolumn += [t2-t1]
        longest = max(longest, t2-t1)
        summed += t2-t1
        
    fraccolumn = [c / summed for c in totalcolumn]

    labels = [
        'Log File',
        'Output Files',
        'Fraction',
        'Total Time',
    ]
    unit = 1.
    if longest > -float('inf'):
        try_units = collections.OrderedDict()
        try_units['s'] = 1.
        try_units['min'] = 60.
        try_units['hr'] = 3600.
        try_units['day'] = 3600. * 24.

        for key, val in try_units.items():
            if longest / val <= 100:
                labels[-1] += ' (' + key + ')'
                totalcolumn = [c / val for c in totalcolumn]
                break

    if '(' not in labels[-1]: labels[-1] += ' (s)'
    
    fraccolumn = ['%7.5f' % c for c in fraccolumn]

    logcolumn += ['']
    outcolumn += ['']
    fraccolumn += ['']
    totalcolumn += [sum([c for c in totalcolumn])]
    
    
    labels = [starsmashertools.bintools.Style.bold(label) for label in labels]
    totalcolumn = ['%13.10f' % c for c in totalcolumn]
    
    return [logcolumn, outcolumn, fraccolumn, totalcolumn], labels

def plot_wall_time():
    # This function contains a whole lot of pain.
    global simulation, cli
    import matplotlib.pyplot as plt
    import matplotlib.transforms
    import matplotlib.dates
    import datetime

    simulation_times = []
    times = []
    for key, val in simulation.get_output_headers().items():
        simulation_times += [val['t']]
        times += [key.get_file_creation_time()]

    simulation_times = np.asarray(simulation_times, dtype=float)

    # Convert simulation times units
    unit = simulation.units['t'] * np.amax(simulation_times)
    unit = unit.auto()
    factor = simulation.units['t'].get_conversion_factor(unit.label)
    factor *= simulation.units['t'].value
    simulation_times *= factor


    # Plot the results as dates
    
    dates = [datetime.datetime.fromtimestamp(time) for time in times]
    datenums = matplotlib.dates.date2num(dates)
    
    x = datenums
    y = simulation_times

    maxval = np.amax(y)

    ylim = [
        min(y),
        max(maxval, simulation['tf'] * factor),
    ]
        
    fig, ax = plt.subplots()
    ax.xaxis.grid(True, alpha=0.2)
    ax.margins(0, 0)

    ax.set_ylabel("simulation time [%s]" % unit.label)
    
    fig.autofmt_xdate() # Make pretty tick labels

    xfmt = matplotlib.dates.DateFormatter('%Y-%m-%d')
    ax.xaxis.set_major_formatter(xfmt)
    
    ax.plot(x, y)

    plt.tight_layout()

    data_xmin = np.nanmin(x)
    data_ymin = np.nanmin(y)
    data_xmax = np.nanmax(x)
    data_ymax = np.nanmax(y)

    xlim = list(ax.get_xlim())
    
    if ylim[1] > max(y):
        # Try to fit a linear function of the most recent half of simulation
        num = max(5, int(len(x) * 0.1))

        slope = np.mean(np.diff(y[-num:]) / np.diff(x[-num:]))
        b = y[-num:][0] - slope * x[-num:][0]

        _xmax = (ylim[1] - b) / slope
        xlim[1] = _xmax
        
        _xmin = min(x[-num:])
        _dx = max(x) - _xmin
        _x = np.linspace(_xmin, _xmax, 2)
        _y = slope * _x + b
        
        ax.plot(_x, _y, label='linear fit', lw=0.5, zorder=-np.inf)

        """
        labels = [
            'quadratic fit',
            'cubic fit',
        ]
        
        for i, label in enumerate(labels):
            coef = np.polyfit(x[-num:], y[-num:], i + 1)
            poly1d_fn = np.poly1d(coef)
            _y = poly1d_fn(_x)
            idx = _x >= min(x)
            if np.any(idx):
                ax.plot(_x[idx], _y[idx], label=label, lw=0.5, zorder=-np.inf)
        """
        cli.write("The function fits shown were created using the most recent half of the data.", flush=True)
        ax.legend()

    # Don't display such a large time range that the data cannot be seen
    # clearly. Make sure the data spans at least some fraction of the axes
    fig.canvas.draw()

    
    bbox = matplotlib.transforms.Bbox(
        [[data_xmin, data_ymin], [data_xmax, data_ymax]],
    )
    bbox = bbox.transformed(ax.transData).transformed(ax.transAxes.inverted())
    if bbox.width < MIN_PLOT_APPARENT_SIZE[0]:
        xlim[1] = data_xmin + (data_xmax - data_xmin) / MIN_PLOT_APPARENT_SIZE[0]
    if bbox.height < MIN_PLOT_APPARENT_SIZE[1]:
        ylim[1] = data_ymin + (data_ymax - data_ymin) / MIN_PLOT_APPARENT_SIZE[1]
    
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)

    

    if cli.args['batch']:
        cli.write("Saving plot as '%s'." % cli.args['plot_name'], flush=True)
        plt.savefig(cli.args['plot_name'])
        return ""
    
    warnings.filterwarnings('error')
    try:
        cli.write("Displaying Matplotlib plot. Please close the plot to continue execution.", flush=True)
        plt.show()
    except UserWarning as e:
        if 'Matplotlib is currently using agg, which is a non-GUI backend, so cannot show the figure.' != str(e):
            raise
        cli.write("Displaying plot failed: '%s'" % str(e), flush=True)
        cli.write("Saving plot as '%s'." % cli.args['plot_name'], flush=True)
        plt.savefig(cli.args['plot_name'])

    return ""
    











################################################################################
################################# Front end ####################################
################################################################################

newline = starsmashertools.bintools.Style.get('characters', 'newline')
starsmashertools.bintools.Style.set('formatting', 'footer', newline)

valid_plots = collections.OrderedDict()
valid_plots['wall time plot'] = {
    'function' : plot_wall_time,
    'default savename' : 'walltime.png',
    'cli name' : 'wall',
}


cli = starsmashertools.bintools.cli.CLI(
    'timing',
    "A tool for analyzing real-world timing data associated with a StarSmasher simulation.",
)

cli.parser.add_argument(
    '-d',
    '--directory',
    nargs='?',
    required=False,
    metavar='directory',
    type=str,
    default=os.getcwd(),
    help='The StarSmasher simulation directory. Defaults to the current working directory if not specified.'
)

cli.parser.add_argument(
    '-b',
    '--batch',
    action='store_true',
    required=False,
    help="Batch mode. This should be used when executing this program in i.e. a bash script or shell.",
)

#cli.parser.add_argument(
#    '--total',
#    action='store_true',
#    required=False,
#    help="Prints the 'total time' option and then exits the program",
#)

cli.parser.add_argument(
    '-p',
    '--plot',
    nargs='?',
    choices=[val['cli name'] for val in valid_plots.values()],
    type=str,
    required=False,
    help="Creates a plot of the given type",
)

cli.parser.add_argument(
    '--plot-name',
    nargs='?',
    type=str,
    required=False,
    metavar='filename',
    help="The name of the image that will be saved when plotting wall time data while in batch mode ('-b') or when option '--plot' is given."
)

simulation = starsmashertools.get_simulation(cli.args['directory'])


mainmenu = cli.add_list(
    [int, str],
    items=[
        #'total time',
        'wall time plot',
    ],
    bullet='%5d)',
    header=newline + starsmashertools.bintools.Style.bold("Main Menu") + newline + newline + 'Choose an option' + newline,
)




#columns, labels = get_time_table()

#timetable = cli.add_table(
#    [],
#    get_time_table,
#    back=mainmenu,
#    indent=4,
#    header=newline,
#)
#mainmenu.connect(timetable, [0, 'total time'])

wt = cli.add_page(
    [],
    plot_wall_time,
    back=mainmenu,
)
mainmenu.connect(wt, [0, 'wall time plot'])

cli.set_mainmenu(mainmenu)


#if cli.args['total']:
#    timetable.show(skip=True)

if cli.args['plot']:
    for key, val in valid_plots.items():
        if val['cli name'] == cli.args['plot']:
            val['function']()
            break
    else:
        raise Exception("Unrecognized plot name '%s'" % cli.args['plot'])

if cli.args['batch'] or cli.args['plot']:# or cli.args['total']:
    quit()

cli.run()
