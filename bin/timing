#!/usr/bin/env python3

# This program is used to measure how much time a StarSmasher simulation took to
# run. It uses os.getmtime to measure timings.

import starsmashertools
import starsmashertools.preferences
import starsmashertools.mpl.plotdata
import starsmashertools.helpers.path
import starsmashertools.bintools.cli
import starsmashertools.bintools
import starsmashertools.helpers.path
import collections
import os
import numpy as np
import warnings
import copy

################################################################################
################################## Back end ####################################
################################################################################

MIN_PLOT_APPARENT_SIZE = (0.25, 0.25)

# Gets set in the front end
simulation = None
cli = None

def get_file_creation_time(filename):
    return os.path.getmtime(filename)

def get_time_table():
    global simulation
    
    logcolumn = []
    outcolumn = []
    totalcolumn = []
    fraccolumn = []

    fmt = "%10s:   %s ... %s"
    filenames = simulation.get_outputfiles()
    longest = -float('inf')
    summed = 0
    for logfile in simulation.get_logfiles():
        logcolumn += [starsmashertools.helpers.path.basename(logfile.path)]

        has = logfile.hasOutputFiles(filenames)
        first = None
        for i, h in enumerate(has):
            if h:
                first = filenames[i]
                break
        last = None
        for i, h in enumerate(has[::-1]):
            if h:
                last = filenames[len(filenames) - i - 1]
                break

        if first is None and last is None:
            totalcolumn += [0]
            continue

        fmt2 = '%s ... %s'
        if None in [first, last]:
            fmt2 = '%s'
        
        outcolumn += ["%s ... %s" % (
            starsmashertools.helpers.path.basename(first),
            starsmashertools.helpers.path.basename(last),
        )]
        t1 = get_file_creation_time(first)
        t2 = get_file_creation_time(last)
        totalcolumn += [t2-t1]
        longest = max(longest, t2-t1)
        summed += t2-t1
        
    fraccolumn = [c / summed for c in totalcolumn]

    labels = [
        'Log File',
        'Output Files',
        'Fraction',
        'Total Time',
    ]
    unit = 1.
    if longest > -float('inf'):
        try_units = collections.OrderedDict()
        try_units['s'] = 1.
        try_units['min'] = 60.
        try_units['hr'] = 3600.
        try_units['day'] = 3600. * 24.

        for key, val in try_units.items():
            if longest / val <= 100:
                labels[-1] += ' (' + key + ')'
                totalcolumn = [c / val for c in totalcolumn]
                break

    if '(' not in labels[-1]: labels[-1] += ' (s)'
    
    fraccolumn = ['%7.5f' % c for c in fraccolumn]

    logcolumn += ['']
    outcolumn += ['']
    fraccolumn += ['']
    totalcolumn += [sum([c for c in totalcolumn])]
    
    
    labels = [starsmashertools.bintools.Style.bold(label) for label in labels]
    totalcolumn = ['%13.10f' % c for c in totalcolumn]
    
    return [logcolumn, outcolumn, fraccolumn, totalcolumn], labels

def plot_wall_time():
    global simulation, cli
    import matplotlib.pyplot as plt
    import matplotlib.transforms
    import matplotlib.dates
    import datetime

    simulation_times = []
    # Try the log files first, for efficiency
    for logfile in simulation.get_logfiles():
        try:
            dtout = float(logfile.get('dtout=').strip().split()[0])
            startfile = logfile.get_first_out_file()
            stopfile = logfile.get_last_out_file()
        except starsmashertools.lib.logfile.LogFile.PhraseNotFoundError:
            # Skip log files that produced no output files
            continue

        dtout = round(dtout, 4)
        
        startfile = starsmashertools.helpers.path.join(
            simulation.directory,
            startfile,
        )
        if not starsmashertools.helpers.path.isfile(startfile):
            raise FileNotFoundError(startfile)
        stopfile = starsmashertools.helpers.path.join(
            simulation.directory,
            stopfile,
        )
        # This can happen when log files have been downloaded but not all output files
        if not starsmashertools.helpers.path.isfile(stopfile):
            continue


        startoutput = starsmashertools.lib.output.Output(startfile, simulation)
        startoutput.read(return_headers=True, return_data=False)
        start = startoutput['t']
        
        start = round(start, 4)
        
        # Check for log files where only 1 output file was produced
        if startfile == stopfile:
            if start not in simulation_times: simulation_times += [start]
        else:            
            stopoutput = starsmashertools.lib.output.Output(stopfile, simulation)
            stopoutput.read(return_headers=True, return_data=False)
            stop = round(stopoutput['t'], 4)
            for a in np.arange(start, stop + dtout, dtout):
                if a not in simulation_times:
                    simulation_times += [a]
    print("printing simulation times", flush=True)
    print(simulation_times, flush=True)
    simulation_times = np.asarray(sorted(simulation_times), dtype=float)

    print(simulation_times, flush=True)
    quit()
    
    times = []
    for output in simulation.get_output_iterator(return_headers=True, return_data=False):
        times += [get_file_creation_time(output.path)]

    
    dates = [datetime.datetime.fromtimestamp(time) for time in times]
    datenums = matplotlib.dates.date2num(dates)
    
    x = datenums
    #y = np.arange(len(filenames))
    y = simulation_times

    print(y)
    quit()
    
    # Convert the y units
    print(np.amax(y), simulation.units['t'])
    quit()
    maxval = np.amax(y) * simulation.units['t']
    unit = maxval.auto()
    factor = simulation.units['t'].get_conversion_factor(
        simulation.units['t'].label,
        unit.label,
    )
    y *= factor

    ylim = [
        min(y),
        max(max(y), simulation['tf'] * simulation.units['t'].value * factor),
    ]


    #ylim = [0, simulation['tf'] / dtout]
    

        
    fig, ax = plt.subplots()
    #twinax = ax.twinx()
    #twinax.yaxis.tick_right()
    ax.xaxis.grid(True, alpha=0.2)
    ax.margins(0, 0)
    #twinax.margins(0, 0)
    #ax.set_ylabel("output file indices")

    ax.set_ylabel("simulation time [%s]" % unit.label)
    
    fig.autofmt_xdate() # Make pretty tick labels

    xfmt = matplotlib.dates.DateFormatter('%Y-%m-%d')
    ax.xaxis.set_major_formatter(xfmt)
    
    ax.plot(x, y)

    data_xmin = np.nanmin(x)
    data_ymin = np.nanmin(y)
    data_xmax = np.nanmax(x)
    data_ymax = np.nanmax(y)

    xlim = list(ax.get_xlim())
    
    if ylim[1] > max(y):
        # Try to fit a linear function of the most recent half of simulation
        num = int(len(x) * 0.5)
        labels = [
            'linear fit',
            'quadratic fit',
            #'cubic fit',
        ]
        
        xmax = -np.inf
        for i, label in enumerate(labels):
            coef = np.polyfit(y[-num:], x[-num:], i + 1)
            poly1d_fn = np.poly1d(coef)
            _y = np.arange(ylim[1])
            _x = poly1d_fn(_y)
            idx = _x >= xlim[0]
            if np.any(idx):
                ax.plot(_x[idx], _y[idx], label=label, lw=0.5, zorder=-np.inf)
                xmax = max(xmax, np.nanmax(_x[idx]))
        cli.write("The function fits shown were created using the most recent half of the data.", flush=True)
        ax.legend()

    # Don't display such a large time range that the data cannot be seen
    # clearly. Make sure the data spans at least some fraction of the axes
    fig.canvas.draw()
    bbox = matplotlib.transforms.Bbox(
        [[data_xmin, data_ymin], [data_xmax, data_ymax]],
    )
    bbox = bbox.transformed(ax.transData).transformed(ax.transAxes.inverted())
    if bbox.width < MIN_PLOT_APPARENT_SIZE[0]:
        xlim[1] = data_xmin + (data_xmax - data_xmin) / MIN_PLOT_APPARENT_SIZE[0]
    if bbox.height < MIN_PLOT_APPARENT_SIZE[1]:
        ylim[1] = data_ymin + (data_ymax - data_ymin) / MIN_PLOT_APPARENT_SIZE[1]
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)

    

    #first = simulation.get_output(0)
    #
    #y2_min = first['t'] * simulation.units['t']
    #y2_max = ylim[1] * dtout * simulation.units['t']
    #y2_max = y2_max.auto()
    #print(first['t'], y2_min, y2_max)
    #y2_min = y2_min.convert(y2_min.label, y2_max.label)
    #print(y2_min, y2_max)
    #twinax.set_ylabel("simulation time (%s)" % y2_max.label)
    #
    #if y2_min > y2_max:
    #    print(y2_min, y2_max)
    #    quit()
    #twinax.set_ylim(float(y2_min), float(y2_max))
    
    #ax.set_ylim(ylim)

    

    plt.tight_layout()

    if cli.args['batch']:
        cli.write("Saving plot as '%s'." % cli.args['plot_name'], flush=True)
        plt.savefig(cli.args['plot_name'])
        return ""
    
    warnings.filterwarnings('error')
    try:
        cli.write("Displaying Matplotlib plot. Please close the plot to continue execution.", flush=True)
        plt.show()
    except UserWarning as e:
        if 'Matplotlib is currently using agg, which is a non-GUI backend, so cannot show the figure.' != str(e):
            raise
        cli.write("Displaying plot failed: '%s'" % str(e), flush=True)
        cli.write("Saving plot as '%s'." % cli.args['plot_name'], flush=True)
        plt.savefig(cli.args['plot_name'])

    return ""
    











################################################################################
################################# Front end ####################################
################################################################################

newline = starsmashertools.bintools.Style.get('characters', 'newline')
starsmashertools.bintools.Style.set('formatting', 'footer', newline)

valid_plots = collections.OrderedDict()
valid_plots['wall time plot'] = {
    'function' : plot_wall_time,
    'default savename' : 'walltime.png',
    'cli name' : 'wall',
}


cli = starsmashertools.bintools.cli.CLI(
    'timing',
    "A tool for analyzing real-world timing data associated with a StarSmasher simulation.",
)

cli.parser.add_argument(
    '-d',
    '--directory',
    nargs='?',
    required=False,
    metavar='directory',
    type=str,
    default=os.getcwd(),
    help='The StarSmasher simulation directory. Defaults to the current working directory if not specified.'
)

cli.parser.add_argument(
    '-b',
    '--batch',
    action='store_true',
    required=False,
    help="Batch mode. This should be used when executing this program in i.e. a bash script or shell.",
)

#cli.parser.add_argument(
#    '--total',
#    action='store_true',
#    required=False,
#    help="Prints the 'total time' option and then exits the program",
#)

cli.parser.add_argument(
    '-p',
    '--plot',
    nargs='?',
    choices=[val['cli name'] for val in valid_plots.values()],
    type=str,
    required=False,
    help="Creates a plot of the given type",
)

cli.parser.add_argument(
    '--plot-name',
    nargs='?',
    type=str,
    required=False,
    metavar='filename',
    help="The name of the image that will be saved when plotting wall time data while in batch mode ('-b') or when option '--plot' is given."
)

simulation = starsmashertools.get_simulation(cli.args['directory'])


mainmenu = cli.add_list(
    [int, str],
    items=[
        #'total time',
        'wall time plot',
    ],
    bullet='%5d)',
    header=newline + starsmashertools.bintools.Style.bold("Main Menu") + newline + newline + 'Choose an option' + newline,
)




#columns, labels = get_time_table()

#timetable = cli.add_table(
#    [],
#    get_time_table,
#    back=mainmenu,
#    indent=4,
#    header=newline,
#)
#mainmenu.connect(timetable, [0, 'total time'])

wt = cli.add_page(
    [],
    plot_wall_time,
    back=mainmenu,
)
mainmenu.connect(wt, [0, 'wall time plot'])

cli.set_mainmenu(mainmenu)


#if cli.args['total']:
#    timetable.show(skip=True)

if cli.args['plot']:
    for key, val in valid_plots.items():
        if val['cli name'] == cli.args['plot']:
            val['function']()
            break
    else:
        raise Exception("Unrecognized plot name '%s'" % cli.args['plot'])

if cli.args['batch'] or cli.args['plot']:# or cli.args['total']:
    quit()

cli.run()
