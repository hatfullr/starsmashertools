#!/usr/bin/env python3

import argparse
import starsmashertools.helpers.jsonfile
import starsmashertools.helpers.path
import re
import sys

bold = '\033[1m'
green = '\033[92m'
red = '\033[91m'
checkmark = u'\N{check mark}'
normal = '\033[0m'

if not sys.stdout.isatty(): # Output is being redirected, i.e. to a file
    green = ''
    red = ''
    bold = ''
    normal = ''

number_pattern = re.compile(r"[0-9]+")

parser = argparse.ArgumentParser(
    prog='inspectpdc',
    description="A tool for viewing the contents of a checkpoint file created by starsmashertools, called 'pdc.json.gzip' by default.",
)

parser.add_argument(
    '-s',
    '--simulation',
    nargs='?',
    required=False,
    metavar='path',
    type=str,
    help='A path to a simulation included in the PDC file. If specified, shows additional information about the files and methods for only that simulation.'
)

parser.add_argument(
    'filename',
    help='The path to a checkpoint PDC file',
)



def get_methods(simdir, pdc, files):
    methods = []
    for f in files:
        for key in pdc[starsmashertools.helpers.path.join(simdir, f)].keys():
            if key not in methods: methods += [key]
    return methods
def print_methods(name, methods):
    print(("      %s = "+", ".join(["'"+a+"'" for a in methods])) % name)


def run():
    args = parser.parse_args()

    simulation = args.simulation

    pdc = starsmashertools.helpers.jsonfile.load(args.filename)

    # Split things up by simulation
    simdirs = []
    outfiles = {}
    for key, val in pdc.items():
        simdir = starsmashertools.helpers.path.dirname(key)
        if simdir not in simdirs: simdirs += [simdir]
        outfile = starsmashertools.helpers.path.basename(key)
        if simdir not in outfiles.keys(): outfiles[simdir] = []
        outfiles[simdir] += [outfile]

    if simulation is None: default(pdc, simdirs, outfiles)
    else:
        if simulation not in simdirs:
            raise ValueError("Simulation not found in PDC file: '%s'" % simulation)
        simulation_mode(pdc, simulation, outfiles)



    
def simulation_mode(pdc, simulation, outfiles):
    files = sorted(outfiles[simulation])
    all_methods = get_methods(simulation, pdc, files)
    
    indent = " "
    padding = " "
    separator = "│"
    top_separator = "┬"
    middle_separator = "┼"
    bottom_separator = "┴"
    top_left = "┌"
    top_right = "┐"
    middle_left = "├"
    middle_right = "┤"
    bottom_left = "└"
    bottom_right = "┘"
    line = "─"

    # Determine column widths
    column_widths = [max([len(f) for f in files])] + [len(method) for method in all_methods]
    ncols = len(column_widths)

    fmt_arr = ["%%%ds" % width for width in column_widths]

    def get_line(content, separator, indent, padding, first_separator=None, last_separator=None, styles=None):
        if first_separator is None: first_separator = separator
        if last_separator is None: last_separator = separator
        if styles is not None:
            my_fmt_arr = [style+a+normal for style, a in zip(styles, fmt_arr)]
        else:
            my_fmt_arr = fmt_arr
        fmt = indent + first_separator + padding + (padding + separator + padding).join(my_fmt_arr) + padding + last_separator
        return fmt % tuple(content)
    
    top = get_line(
        [line*width for width in column_widths],
        top_separator,
        indent, line,
        first_separator=top_left,
        last_separator=top_right,
    )

    
    header = get_line(
        ["file"] + all_methods,
        separator,
        indent,
        padding,
        styles = [bold for i in range(len(all_methods)+1)],
    )

    middle = get_line(
        [line*width for width in column_widths],
        middle_separator,
        indent,
        line,
        first_separator=middle_left,
        last_separator=middle_right,
    )

    bottom = get_line(
        [line*width for width in column_widths],
        bottom_separator,
        indent,
        line,
        first_separator=bottom_left,
        last_separator=bottom_right,
    )


    print(top)
    print(header)
    print(middle)
    
    for f in files:
        methods = list(pdc[starsmashertools.helpers.path.join(simulation, f)].keys())
        toprint = [f]
        styles = [""]
        for method in all_methods:
            if method in methods:
                toprint += [checkmark]
                styles += [green]
            else:
                toprint += ["X"]
                styles += [red]
        print(get_line(
            toprint,
            separator,
            indent,
            padding,
            styles = styles,
        ))
    
    print(bottom)
    

diff = 0
nums = None
def default(pdc, simdirs, outfiles):
    global diff, nums
    def get_file_groups(files, is_ingroup, on_newgroup):
        groups = []
        for i, f in enumerate(files):
            if i == 0:
                groups = [[files[0]]]
                continue

            if is_ingroup(files[i-1], files[i], i-1, i):
                # Update the 'last' member of the group
                if len(groups[-1]) == 1:
                    groups[-1] += [f]
                else:
                    groups[-1][1] = f
            else:
                # Start a new group
                groups += [[f]]
                on_newgroup(i-1, i)
        return groups

    diff = 0
    def is_ingroup_filenumber_aligned_methods(file1, file2, idx1, idx2):
        global diff, nums
        matches_current_file_patterns = None not in [nums[idx1], nums[idx2]] and nums[idx2] - nums[idx1] == diff
        return matches_current_file_patterns

    def on_newgroup_filenumber_aligned_methods(idx1, idx2):
        global diff, nums
        if None not in [nums[idx1], nums[idx2]]:
            if idx2 + 1 < len(nums):
                diff = nums[idx2+1] - nums[idx2]
            else:
                diff = nums[idx2] - nums[idx1]


    for simdir in sorted(simdirs):
        files = sorted(outfiles[simdir])

        # Move through the files to find "contiguous groupings".
        # We are trying to detect patterns to the outputs, i.e.,
        # if we have out0000.sph, out0001.sph, out0002.sph,
        # out0010.sph, then we should display something like
        # 'out0000.sph .. out0002.sph, out0010.sph'. But only
        # do this if all the output files are actually numbered.

        # For testing
        #pdc[starsmashertools.helpers.path.join(simdir, files[10])]['get_x'] = None
        #pdc[starsmashertools.helpers.path.join(simdir, files[11])]['get_x'] = None
        #pdc[starsmashertools.helpers.path.join(simdir, files[12])]['get_x'] = None
        #pdc[starsmashertools.helpers.path.join(simdir, files[50])]['get_x'] = None

        all_methods = get_methods(simdir, pdc, files)
        
        needs_calculating = []
        for i,f in enumerate(files):
            obj = pdc[starsmashertools.helpers.path.join(simdir,f)]
            keys = obj.keys()
            if (None in obj.values() or any([a not in keys for a in all_methods])):
                needs_calculating += [f]

        if needs_calculating: print(red+"X"+normal+"  "+simdir)
        else: print(green+checkmark+normal+"  "+simdir)

        print_methods("all methods", all_methods)
        
        files = [f for f in files if f not in needs_calculating]

        nums = []
        for f in files:
            match = number_pattern.search(f)
            if match is not None:
                nums += [int(match.group(0))]
        diff = 0
        if len(nums) > 1 and None not in [nums[0], nums[1]]: diff = nums[1] - nums[0]

        groups = get_file_groups(
            files,
            is_ingroup_filenumber_aligned_methods,
            on_newgroup_filenumber_aligned_methods
        )
        if groups:
            strings = ["         " + " ... ".join(group) for group in groups]
            string = "\n".join(strings)
            print("      Up-to-date")
            print(string)

        nums = []
        for f in needs_calculating:
            match = number_pattern.search(f)
            if match is not None:
                nums += [int(match.group(0))]
        diff = 0
        if len(nums) > 1 and None not in [nums[0], nums[1]]: diff = nums[1] - nums[0]
        groups = get_file_groups(
            needs_calculating,
            is_ingroup_filenumber_aligned_methods,
            on_newgroup_filenumber_aligned_methods,
        )
        if groups:
            strings = ["         " + " ... ".join(group) for group in groups]
            string = "\n".join(strings)
            print(red+"      Needs calculating")
            print(string+normal)
        print("")





run()
