#!/usr/bin/env python3

import argparse
import starsmashertools.helpers.jsonfile
import starsmashertools.helpers.path
import re

green = '\033[92m'
red = '\033[91m'
normal = '\033[0m'

parser = argparse.ArgumentParser(
    prog='inspectpdc',
    description="A tool for viewing the contents of a checkpoint file created by starsmashertools, called 'pdc.json.gzip' by default.",
)

parser.add_argument('filename') # positional argument



args = parser.parse_args()

pdc = starsmashertools.helpers.jsonfile.load(args.filename)

# Split things up by simulation
simdirs = []
outfiles = {}
for key, val in pdc.items():
    simdir = starsmashertools.helpers.path.dirname(key)
    if simdir not in simdirs: simdirs += [simdir]
    outfile = starsmashertools.helpers.path.basename(key)
    if simdir not in outfiles.keys(): outfiles[simdir] = []
    outfiles[simdir] += [outfile]

number_pattern = re.compile(r"[0-9]+")


def get_file_groups(files, is_ingroup, on_newgroup):
    groups = []
    for i, f in enumerate(files):
        if i == 0:
            groups = [[files[0]]]
            continue

        if is_ingroup(files[i-1], files[i], i-1, i):
            # Update the 'last' member of the group
            if len(groups[-1]) == 1:
                groups[-1] += [f]
            else:
                groups[-1][1] = f
        else:
            # Start a new group
            groups += [[f]]
            on_newgroup(i-1, i)
    return groups

diff = 0
def is_ingroup_filenumber_aligned_methods(file1, file2, idx1, idx2):
    global diff, nums
    matches_current_file_patterns = None not in [nums[idx1], nums[idx2]] and nums[idx2] - nums[idx1] == diff
    return matches_current_file_patterns

def on_newgroup_filenumber_aligned_methods(idx1, idx2):
    global diff, nums
    if None not in [nums[idx1], nums[idx2]]:
        if idx2 + 1 < len(nums):
            diff = nums[idx2+1] - nums[idx2]
        else:
            diff = nums[idx2] - nums[idx1]

    
for simdir in sorted(simdirs):
    files = sorted(outfiles[simdir])
    
    # Move through the files to find "contiguous groupings".
    # We are trying to detect patterns to the outputs, i.e.,
    # if we have out0000.sph, out0001.sph, out0002.sph,
    # out0010.sph, then we should display something like
    # 'out0000.sph .. out0002.sph, out0010.sph'. But only
    # do this if all the output files are actually numbered.

    # For testing
    #pdc[starsmashertools.helpers.path.join(simdir, files[10])]['get_x'] = None
    #pdc[starsmashertools.helpers.path.join(simdir, files[11])]['get_x'] = None
    #pdc[starsmashertools.helpers.path.join(simdir, files[12])]['get_x'] = None
    #pdc[starsmashertools.helpers.path.join(simdir, files[50])]['get_x'] = None

    all_methods = []
    for f in files:
        for key in pdc[starsmashertools.helpers.path.join(simdir, f)].keys():
            if key not in all_methods: all_methods += [key]
    
    needs_calculating = []
    for i,f in enumerate(files):
        obj = pdc[starsmashertools.helpers.path.join(simdir,f)]
        keys = obj.keys()
        if (None in obj.values() or any([a not in keys for a in all_methods])):
            needs_calculating += [f]

    if needs_calculating: print(red+"X"+normal+"   "+simdir)
    else: print(green+u'\N{check mark}'+normal+"   "+simdir)

    print("   all methods = "+", ".join(["'"+a+"'" for a in all_methods]))
            
    files = [f for f in files if f not in needs_calculating]
    
    nums = []
    for f in files:
        match = number_pattern.search(f)
        if match is not None:
            nums += [int(match.group(0))]
    diff = 0
    if len(nums) > 1 and None not in [nums[0], nums[1]]: diff = nums[1] - nums[0]
    
    groups = get_file_groups(
        files,
        is_ingroup_filenumber_aligned_methods,
        on_newgroup_filenumber_aligned_methods
    )
    if groups:
        strings = ["      " + " ... ".join(group) for group in groups]
        string = "\n".join(strings)
        print("   Up-to-date")
        print(string)

    nums = []
    for f in needs_calculating:
        match = number_pattern.search(f)
        if match is not None:
            nums += [int(match.group(0))]
    diff = 0
    if len(nums) > 1 and None not in [nums[0], nums[1]]: diff = nums[1] - nums[0]
    groups = get_file_groups(
        needs_calculating,
        is_ingroup_filenumber_aligned_methods,
        on_newgroup_filenumber_aligned_methods,
    )
    if groups:
        strings = ["      " + " ... ".join(group) for group in groups]
        string = "\n".join(strings)
        print(red+"   Needs calculating")
        print(string+normal)
        print("")

    
