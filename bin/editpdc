#!/usr/bin/env python3

# This program is structured poorly and written hastily. You have been warned.

import argparse
import starsmashertools.mpl.plotdata
import starsmashertools.helpers.path
import starsmashertools.helpers.string
import re
import sys
import traceback
import os
import warnings

formats = {
    'prompt question' : '{text}',
    'prompt' : ': ',
    'list header' : '{text}',
    'list item' : ' {bullet:>6s} {text}',
    'numbered list item' : ' {num:5d}) {text}',
}

parser = argparse.ArgumentParser(
    prog='editpdc',
    description="A tool for editing the contents of a checkpoint file created by starsmashertools, called 'pdc.json.gz' by default.",
)

parser.add_argument(
    '-o',
    '--output',
    nargs='?',
    required=False,
    metavar='path',
    type=str,
    help='The output file to write the edited PDC file to. If not specified then the original PDC file will be overwritten.'
)

parser.add_argument(
    'filename',
    nargs='?',
    help='The checkpoint PDC file that will be edited',
)

args = parser.parse_args()
filename = args.filename
output = args.output

if filename is None:
    raise Exception("Missing positional argument 'filename'")

if not os.path.isfile(filename):
    raise FileNotFoundError(filename)

if output is None: output = filename

pdc = starsmashertools.mpl.plotdata.JSONObject(filename)
pdc.load()

def save():
    pdc.filename = output
    warnings.filterwarnings(action='ignore')
    pdc.save()
    warnings.resetwarnings()

class InvalidInputError(Exception):
    __module__ = Exception.__module__
    def __init__(self, *args, **kwargs):
        super(InvalidInputError, self).__init__(*args, **kwargs)

def print_numbered_list(header, items, indent=0):
    print("")
    if header:
        print(" "*indent + formats['list header'].format(text=header))
        print("")
    for i, text in enumerate(items):
        print(" "*indent + formats['numbered list item'].format(num=i,text=text))
    print("")

def print_prompt(text, indent=0):
    print(" "*indent + formats['prompt question'].format(text=text))

def numbered_list_prompt(items, prompt="", header=None, back=False, all=False, indent=0):
    print_numbered_list(header, items, indent=indent)
    if back:
        print(" "*indent + formats['list item'].format(bullet="b)", text="Back"))
    if all:
        print(" "*indent + formats['list item'].format(bullet="a)", text="All"))

    print(" "*indent + formats['list item'].format(bullet="s)", text="Save"))
    print(" "*indent + formats['list item'].format(bullet="q)", text="Quit"))
    print("")
    
    if prompt:
        print_prompt(prompt,indent=indent)
    
    while True:
        inp = get_input(allowed_types=[int,str])
        
        if isinstance(inp, str):
            if back and inp in ['b', 'back']: return None
            if all and inp in ['a', 'all']: return items
            if inp in ['q', 'quit']: quit()
            if inp in ['s', 'save']:
                save()
                return numbered_list_prompt(items, prompt=prompt,header=header,back=back,all=all,indent=indent)
            if inp in items: return inp
        elif isinstance(inp, int) and inp >= 0 and inp < len(items):
            return items[inp]
            break
        print_error_message(InvalidInputError("Invalid selection '%s'" % inp))


def print_error_message(error):
    if isinstance(error, str):
        print(error)
    else:
        try:
            raise(error)
        except:
            print(traceback.format_exc().split('\n')[-2])

def parse_input(text, allowed_types=[]):
    text = text.lower().strip()
    
    if not allowed_types:
        return starsmashertools.helpers.string.parse(text)

    # Check easy definitive types first
    if bool in allowed_types and text in ['true', 'false']:
        return bool(text)

    if float in allowed_types and ('.' in text or 'e' in text or 'd' in text):
        try:
            return float(text)
        except ValueError as e:
            if 'could not convert string to float' not in str(e):
                raise

    if int in allowed_types:
        try:
            return int(text)
        except ValueError as e:
            if 'invalid literal for int() with base 10:' not in str(e):
                raise
            
    if str in allowed_types:
        return text
            
    raise InvalidInputError("Cannot convert input to any of the following types: "+", ".join(["'%s'" % t.__name__ for t in allowed_types]))



def get_input(**kwargs):
    return parse_input(input(formats['prompt']), **kwargs)





class InputManager(object):
    def __init__(self, parent=None):
        super(InputManager, self).__init__()
        self.pages = {}
        self.current_page = None
        self.starting_page = None
        self.parent = None

    def start(self):
        if self.starting_page is None:
            raise Exception("Missing starting page")
        self.starting_page.show()
        
    def add_page(self, identifier, print_method, parent=None, starting_page=False, **kwargs):
        page = InputManager.Page(self, print_method, parent=parent, **kwargs)
        if starting_page:
            if parent is not None:
                raise Exception("The starting page must have a None parent")
            self.starting_page = page
        self.pages[identifier] = page
        if parent is not None:
            parent.children += [page]
        return page
        

    class Page(object):
        def __init__(self, manager, print_method, parent=None, function=None, endpage=False):
            super(InputManager.Page, self).__init__()
            self.manager = manager
            self.print_method = print_method
            self.parent = parent
            self.children = []
            self.function = function
            self.endpage = endpage

        def show(self):
            result = self.print_method()
            if self.function is not None: result = self.function(result)
            
            if result is None: self.back()
            elif result == 'editpdc_loop': self.show()
            elif not self.endpage: self.children[result].show()
            else: self.main_menu()
        
        def back(self):
            if self.parent is None:
                if self.manager.parent is not None:
                    self.manager.parent.start()
                    return
                else:
                    raise Exception("Cannot go back on a page with a None parent")
            else:
                self.parent.show()

        # Return to the root
        def main_menu(self):
            parent = self.parent
            if parent is None: self.show()
            else:
                while parent.parent is not None:
                    parent = parent.parent
                parent.show()
                



def get_simulations():
    # Get the simulations
    simulations = []
    for key in pdc.keys():
        simdir = pdc._get_simdir(key)
        if simdir not in simulations:
            simulations += [simdir]
    return sorted(simulations)



    

def simulation_workflow():
    return select_simulation(header='Select a simulation to edit.', back=True)

def main_menu():
    global manager

    print("")
    print("Main Menu")
    print("")
    print("    Filename: %s" % filename)
    print("      Output: %s" % output)
    
    # Get the methods
    methods = pdc.get_all_method_names()
    
    def print_main_page():
        inp = numbered_list_prompt(
            methods,
            header="Select a method to edit.",
            back=True,
        )
        if inp is None: return inp
        return methods.index(inp)
    return print_main_page()


def select_simulation(method=None, header='Select a simulation.',back=False,all=False):
    simulations = get_simulations()
    if method is not None:
        filtered_simulations = []
        for simulation in simulations:
            for filename, obj in pdc.items():
                if pdc._get_simdir(filename) == simulation:
                    if method in obj.keys():
                        filtered_simulations += [simulation]
                        break
            #else: # If none of the files in this simulation has the given method name,
        simulations = filtered_simulations

    inp = numbered_list_prompt(
        simulations,
        header=header,
        back=back,
        all=all,
    )
    if inp is None: return None
    elif isinstance(inp, list): return inp
    return simulations.index(inp)
        

def delete_method_in_files(method, filenames):
    for filename in filenames:
        pdc[filename].pop(method, None)

def delete_method_in_simulation(method, simulation):
    if isinstance(simulation, int):
        simulation = get_simulations()[simulation]
    simulation = os.path.basename(simulation)
    for filename in pdc.keys():
        if simulation == pdc._get_simdir(filename):
            delete_method_in_files(method, [filename])

def delete_method_in_all_files(method):
    for key, val in pdc.items():
        delete_method_in_files(method, [key])

def get_confirmation(message='Are you sure? (y/n)', confirmer='y'):
    print_prompt(message)
    inp = get_input(allowed_types=[str])
    return inp == confirmer

def print_files():
    filenames = pdc.keys()
    inp = numbered_list_prompt(
        filenames,
        header='Select a file.',
        back=True,
        all=True,
    )
    if inp is None: return None
    if isinstance(inp, list): return inp
    return filenames.index(inp)

def add_method_page(manager, parent, method):
    def function(result, method):
        if result is None: return None
        if hasattr(result, '__iter__') and not isinstance(result, str):
            if get_confirmation(message='Delete %s in all simulations? (y/n)' % method):
                delete_method_in_all_files(method)
        else:
            if get_confirmation(message='Delete %s in this simulation? (y/n)' % method):
                delete_method_in_simulation(method, result)
        
        return None
                
    
    page = manager.add_page(
        'Select Simulation',
        lambda all=True, parent=parent: select_simulation(method=method,all=all,back=parent is not None),
        parent=parent,
        function=lambda result, method=method: function(result, method),
        endpage=True,
    )
    
    
manager = InputManager()
mainmenu = manager.add_page(
    'Main Menu',
    main_menu,
    starting_page=True,
)
# Get the methods
methods = pdc.get_all_method_names()
for method in methods:
    add_method_page(manager, mainmenu, method)

manager.start()

